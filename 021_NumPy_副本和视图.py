import numpy as np

'''
副本：数据的完整的拷贝。对拷贝修改不影响原数据，物理内存不在一起
视图：数据的别称或引用，通过这个别称或者引用即可访问、操作，不产生拷贝，修改视图影响原数据，物理内存在同一位置

副本发生在：
1.python序列的切片操作，调用deepcopy()函数
2.调用ndarray.copy()

视图发生在：
1.numpy切片操作返回原数据的视图
2.调用ndarray.view()
'''

print('-----------------------------------------')
# 赋值不创建副本 id相同，修改赋值对象，也会修改原数据
a = np.arange(6)
print(a)
print(id(a)) # id() 返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的,类似于指针
b = a
print(b)
print(id(b))
b.shape = 3,2
print(b)
print(a)

print('-----------------------------------------')
# 视图或浅拷贝
# view 创建新的数组对象 id不同，修改新的数组对象，不修改原数据
a = np.arange(6).reshape(3, 2)
print(a)
b = a.view() # view() 创建一个新的数组对象。维度变化并不改变原始数据的维度
print(b)
print(id(a))
print(id(b))
b.shape = 2,3
print(b) # 修改b形状 并不修改a
print(a)

print('-----------------------------------------')
# 切片仍是原数据的视图 id不同 视图指向原数据，修改切片原数据也修改
arr = np.arange(12)
print(a)
a = arr[3:]
b = arr[3:]
a[1] = 123
b[2] = 234
print(arr) # 切片创建视图 修改数据会影响到原始数组
print(id(a), id(b), id(arr[3:]))
# a, b 都是arr的一小部分视图。对视图的修改直接反映到原数据中，但ab的id不同，视图虽然指向原数据，但与赋值引用有区别

print('-----------------------------------------')
# 副本或深拷贝 id不同 修改拷贝原数据不修改
a = np.array([[10, 10], [2, 3], [4, 5]])
print(a)
b = a.copy() # copy函数创建一个副本，副本修改不影响原始数据，物理内存不在同一位置
print(b)
print(id(a), id(b))
b[0, 0] = 1
print(a)
print(b)